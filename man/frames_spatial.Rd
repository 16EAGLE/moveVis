% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/frames_spatial.R
\name{frames_spatial}
\alias{frames_spatial}
\title{Create frames of spatial movement maps for animation}
\usage{
frames_spatial(
  m,
  r = NULL,
  r_type = "gradient",
  fade_raster = FALSE,
  crop_raster = TRUE,
  map_service = "osm",
  map_type = "streets",
  map_res = 1,
  map_token = NULL,
  map_dir = NULL,
  margin_factor = 1.1,
  equidistant = NULL,
  ext = NULL,
  crs = if (is.null(r)) st_crs(3857) else st_crs(terra::crs(r)),
  crs_graticule = st_crs(4326),
  path_size = 3,
  path_end = "round",
  path_join = "round",
  path_mitre = 10,
  path_arrow = NULL,
  path_colours = NA,
  path_alpha = 1,
  path_fade = FALSE,
  path_legend = TRUE,
  path_legend_title = "Names",
  tail_length = 19,
  tail_size = 1,
  tail_colour = "white",
  trace_show = FALSE,
  trace_size = tail_size,
  trace_colour = "white",
  cross_dateline = FALSE,
  ...,
  verbose = TRUE
)
}
\arguments{
\item{m}{\code{move2} object of uniform time scale and time lag as returned by \code{\link{align_move}}. Can contain a column named \code{colour} to control path colours (see details below).}

\item{r}{\code{terra} object, either a \code{SpatRaster} (mono-temporal) or a \code{SpatRasterDataset} (multi-temporal). In case of the latter, times of `r` must be defined as 'POSIXct' (see \code{\link[terra]{time}} and details below).}

\item{r_type}{character, either \code{"gradient"} or \code{"discrete"}. Ignored, if \code{r} contains three bands, which are treated as RGB.}

\item{fade_raster}{logical, if \code{TRUE}, \code{r} is interpolated over time. If \code{FALSE}, \code{r} elements are assigned to those frames closest to the equivalent times of \code{r}.}

\item{crop_raster}{logical, whether to crop rasters in \code{r} to frame extents before plotting or not.}

\item{map_service}{character, a map service, e.g. \code{"osm"}. Use \code{\link{get_maptypes}} for a list of available map services and types..}

\item{map_type}{character, a map type, e.g. \code{"streets"}. Use \code{\link{get_maptypes}} for available map services and types.}

\item{map_res}{numeric, resolution of base map in range from 0 to 1.}

\item{map_token}{character, mapbox authentification token for mapbox basemaps. Register at \url{https://www.mapbox.com/} to get a mapbox token. Mapbox is free of charge after registration for up to 50.000 map requests per month. Ignored, if \code{map_service = "osm"}.}

\item{map_dir}{character, directory where downloaded basemap tiles can be stored. By default, a temporary directory is used. 
If you use moveVis often for the same area it is recommended to set this argument to a directory persistent throughout sessions (e.g. in your user folder), 
so that baesmap tiles that had been already downloaded by moveVis do not have to be requested again.}

\item{margin_factor}{numeric, factor relative to the extent of \code{m} by which the frame extent should be increased around the movement area. Ignored, if \code{ext} is set.}

\item{equidistant}{logical, whether to make the map extent equidistant (squared) with y and x axis measuring equal distances or not. Especially in polar regions of the globe it might be necessaray to set \code{equidistant} to \code{FALSE} to avoid strong stretches. By default (\code{equidistant = NULL}), equidistant is set automatically to \code{FALSE}, if \code{ext} is set, otherwise \code{TRUE}. Read more in the details.}

\item{ext}{\code{sf bbox} in same CRS as \code{m}, optional. If set, frames are cropped to this extent. If not set, the extent is computed from \code{m}, optionally with a margin set by \code{margin_factor}.}

\item{crs}{\code{sf crs} object. This is the CRS that is used for visualizing both movement and map data. Defaults to \code{st_crs(3857)} (Web Mercator), unless \code{r} is defined. In that case, \code{st_crs(r)} is used.}

\item{crs_graticule}{\code{sf crs} object. This is the CRS that should be used to generate graticules. By default, geographic coordinates (Lon/Lat WGS84, EPSG:4326) is used.}

\item{path_size}{numeric, size of each path.}

\item{path_end}{character, either \code{"round"}, \code{"butt"} or \code{"square"}, indicating the path end style.}

\item{path_join}{character, either \code{"round"}, \code{"mitre"} or \code{"bevel"}, indicating the path join style.}

\item{path_mitre}{numeric, path mitre limit (number greater than 1).}

\item{path_arrow}{arrow, path arrow specification, as created by grid::arrow().}

\item{path_colours}{character, a vector of colours. Must be of same length as number of individual tracks in \code{m} and refers to the order of tracks in \code{m}. If undefined (\code{NA}) and \code{m} contains a column named \code{colour}, colours provided within \code{m} are used (see details). Othwersie, colours are selected from a standard rainbow palette per individual track.}

\item{path_alpha}{numeric, defines alpha (transparency) of the path. Value between 0 and 1. Default is 1.}

\item{path_fade}{logical, whether paths should be faded towards the last frame or not. Useful, if \code{trace_show = TRUE} and you want to hold the last frame using \code{end_pause} in \code{\link{animate_frames}}.}

\item{path_legend}{logical, wether to add a path legend from \code{m} or not. Legend tracks and colours will be ordered by the tracks' temporal apperances, not by their order in \code{m}.}

\item{path_legend_title}{character, path legend title. Default is \code{"Names"}.}

\item{tail_length}{numeric, length of tail per movement path.}

\item{tail_size}{numeric, size of the last tail element. Default is 1.}

\item{tail_colour}{character, colour of the last tail element, to which the path colour is faded. Default is "white".}

\item{trace_show}{logical, whether to show the trace of the complete path or not.}

\item{trace_size}{numeric, size of the trace. Default is same as \code{tail_size}.}

\item{trace_colour}{character, colour of the trace. Default is "white". It is recommended to define the same colours for both \code{trace_colour} and  \code{tail_colour} to enforce an uninterrupted colour transition form the tail to the trace.}

\item{cross_dateline}{logical, whether tracks are crossing the dateline (longitude 180/-180) or not. If \code{TRUE}, frames are expanded towards the side of the dateline that is smaller in space. Applies only if the CRS of \code{m} is not projected (geographical, lon/lat). If \code{FALSE} (default), frames are clipped at the minimum and maximum longitudes and tracks cannot cross.}

\item{...}{Additional arguments customizing the frame background:
\itemize{
    \item \code{alpha}, numeric, background transparency (0-1).
    \item \code{maxpixels}, maximum number of pixels to be plotted per frame. Defaults to 500000. Reduce to decrease detail and increase rendering speeds.
    \item \code{maxColorValue}, numeric, only relevant for RGB backgrounds (i.e. if \code{r_type = "RGB"} or if a default base map is used). Maximum colour value (e.g. 255). Defaults to maximum raster value.
    \item \code{interpolate}, logical, whether to spatially smooth the map raster (default is \code{FALSE}).
}}

\item{verbose}{logical, if \code{TRUE}, messages and progress information are displayed on the console (default).}
}
\value{
A frames object of class \code{moveVis}.
}
\description{
\code{frames_spatial} creates frames from movement and map/raster data. If no custom raster data is provided, a basemap is pulled from a map tile service using the \code{basemaps} package. Frames are returned as an object of class \code{moveVis} and can be subsetted, viewed (see \code{\link{render_frame}}), modified (see \code{\link{add_gg}} and associated functions ) and animated (see \code{\link{animate_frames}}).
}
\details{
If argument \code{path_colours} is not defined (set to \code{NA}), path colours can be defined by adding a character column named \code{colour} to \code{m}, containing a colour code or name per row (e.g. \code{"red"}. This way, for example, column \code{colour} for all rows belonging to individual A can be set to \code{"green"}, while column \code{colour} for all rows belonging to individual B can be set to \code{"red"}.
Colours could also be arranged to change through time or by behavioural segments, geographic locations, age, environmental or health parameters etc. If a column name \code{colour} in \code{m} is missing, colours will be selected using \code{path_colours} or automatically. Call \code{colours()} to see all available colours in R.

Basemap colour scales can be changed/added using \code{\link{add_colourscale}} or by using \code{ggplot2} commands (see \code{examples}). For continuous scales, use \code{r_type = "gradient"}. For discrete scales, use \code{r_type = "discrete"}.

If argument \code{equidistant} is set, the map extent is calculated (thus enlarged into one axis direction) to represent equal distances on the x and y axis.
}
\note{
The use of some map services, e.g. \code{"osm_stadia"}, \code{"osm_thunderforest"} or \code{"mapbox"}, require registration to obtain an API token/key which can be supplied to \code{map_token}. See \code{\link[basemaps]{get_maptypes}} for details.

The Coordinate Reference System defined by argument \code{crs} is treated as target projection. Both \code{m}, basemaps accessed through a map service, or custom imagery provided through argument \code{r} will be reprojected into \code{crs}. The default CRS is Web Mercator (EPSG 3857), which guarantees undistorted map labels in web basemap imagery.
}
\examples{
library(moveVis)
library(move2)
library(terra)

# Example using multi-temporal raster data as basemap
data("move_data")

# align movement
m <- align_move(move_data, res = units::set_units(4, "min"))

# get available map types
get_maptypes()

# with osm topographic base map
\dontrun{
frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic",
  alpha = 0.5
)
# take a look at one of the frames, e.g. the 100th
frames[[100]]

frames <- frames \%>\% 
  add_northarrow(position = "bottomleft") \%>\% 
  add_scalebar(colour = "black", position = "bottomright") \%>\% 
  add_progress() \%>\% 
  add_timestamps(type = "label")
  
frames[[100]]

# animate frames as GIF
out_file <- tempfile(fileext = ".gif")
animate_frames(frames, out_file = out_file)
browseURL(out_file) # view animation

# use a larger margin around extent
frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic", alpha = 0.5,
  margin_factor = 1.8
)
frames[[100]] # take a look

# use a extent object as your AOI
ext <- sf::st_bbox(move_data)
ext[["xmin"]] <- ext[["xmin"]] - (ext[["xmin"]]*0.03)
ext[["xmax"]] <- ext[["xmax"]] + (ext[["xmax"]]*0.03)

frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic", alpha = 0.5,
  ext = ext
)
frames[[100]]

# alter path appearance (make it longer and bigger)
frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic", alpha = 0.5,
  path_size = 4, tail_length = 29
)
frames[[100]]

# adjust path colours manually
frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic", alpha = 0.5,
  path_colours = c("black", "blue", "purple")
)
frames[[100]]

m$colour <- plyr::mapvalues(
  as.character(mt_track_id(m)), 
  unique(mt_track_id(m)), c("orange", "purple", "darkgreen")
)

frames <- frames_spatial(
  m, map_service = "osm", map_type = "topographic", alpha = 0.5
)
frames[[100]]

}
# create frames from custom (multi-temporal) basemaps
r <- readRDS(example_data(file = "raster_NDVI.rds"))

# timestamps of each raster are stored in the SpatRasterDataset:
time(r)

# create frames
frames <- frames_spatial(
  m, r = r, r_type = "gradient", 
  fade_raster = TRUE
)

# customize
frames <- frames \%>\% 
  add_colourscale(
    type = "gradient", colours = c("orange", "white", "darkgreen"),
    legend_title = "NDVI") \%>\% 
  add_northarrow(position = "bottomleft") \%>\% 
  add_scalebar(colour = "white", position = "bottomright") \%>\% 
  add_progress() \%>\% 
  add_timestamps(type = "label")
  
# render a single frame
frames[[100]]

# check available animation file formats
suggest_formats()

\dontrun{
# animate frames as GIF
out_file <- tempfile(fileext = ".gif")
animate_frames(frames, out_file = out_file)
browseURL(out_file) # view animation

# animate frames as mov
out_file <- tempfile(fileext = ".mov")
animate_frames(frames, out_file = out_file)
browseURL(out_file) # view animation
}
}
\seealso{
\code{\link{frames_graph}} \code{\link{join_frames}} \code{\link{animate_frames}}
}
\author{
Jakob Schwalb-Willmann
}
